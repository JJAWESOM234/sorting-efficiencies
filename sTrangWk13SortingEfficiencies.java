/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 * Filename: sTrangWk13SortingEfficiencies
 *
 * Programmer: Sydney Trang
 *
 * Course: ICS4UE
 *
 * Date Started: Not sure how long ago.
 *
 * Description: A program that lists random integers, sorts the integers in
 * ascending or descending order and uses one of the four sorting routines:
 * selection, bubble, insertion, and merge. The program also displays counters
 * for the number of times that a loop is executed, the number of times that a
 * comparison is made, the number of times a value was shifted from one
 * location to another, and the actual time, in milliseconds, that it took to
 * complete the sort.
 *
 * Due Date: Sunday, May 13, 2018
 *
 * Modifications: Error handling for if the user does not select one button from
 * each of the two button groups. Every instant the sort numbers button is
 * clicked, previous sort results are cleared.
 *
 */
public class sTrangWk13SortingEfficiencies extends javax.swing.JFrame {

    /**
     * Creates new form sTrangWk13SortingEfficiencies
     */
    public sTrangWk13SortingEfficiencies() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        sortingOrder = new javax.swing.ButtonGroup();
        amtNumsSort = new javax.swing.ButtonGroup();
        title = new javax.swing.JLabel();
        enterInfo = new javax.swing.JLabel();
        sortOrder = new javax.swing.JLabel();
        ascending = new javax.swing.JRadioButton();
        descending = new javax.swing.JRadioButton();
        sortNumbers = new javax.swing.JButton();
        origNums = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        originalNumsOut = new javax.swing.JTextArea();
        sortedNums = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        sortNumsOut = new javax.swing.JTextArea();
        exit = new javax.swing.JButton();
        tenNumsIn = new javax.swing.JRadioButton();
        hundNumsIn = new javax.swing.JRadioButton();
        thousNumsIn = new javax.swing.JRadioButton();
        fiveThousNumsIn = new javax.swing.JRadioButton();
        sortResults = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        sortResultsOut = new javax.swing.JTextArea();
        errorHandling = new javax.swing.JTextField();
        jSeparator1 = new javax.swing.JSeparator();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        title.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        title.setForeground(new java.awt.Color(0, 51, 255));
        title.setText("Sorting Efficiencies");

        enterInfo.setText("Enter the amount of numbers in the list:");

        sortOrder.setText("Sort Order:");

        sortingOrder.add(ascending);
        ascending.setText("Ascending");

        sortingOrder.add(descending);
        descending.setText("Descending");

        sortNumbers.setText("Sort Numbers");
        sortNumbers.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sortNumbersActionPerformed(evt);
            }
        });

        origNums.setText("Original Numbers");

        jScrollPane3.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        originalNumsOut.setColumns(20);
        originalNumsOut.setRows(5);
        jScrollPane3.setViewportView(originalNumsOut);

        sortedNums.setText("Sorted Numbers");

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        sortNumsOut.setColumns(20);
        sortNumsOut.setRows(5);
        jScrollPane1.setViewportView(sortNumsOut);

        exit.setText("Exit");
        exit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitActionPerformed(evt);
            }
        });

        amtNumsSort.add(tenNumsIn);
        tenNumsIn.setText("10");

        amtNumsSort.add(hundNumsIn);
        hundNumsIn.setText("100");

        amtNumsSort.add(thousNumsIn);
        thousNumsIn.setText("1000");

        amtNumsSort.add(fiveThousNumsIn);
        fiveThousNumsIn.setText("5000");

        sortResults.setText("Sort Results");

        sortResultsOut.setColumns(20);
        sortResultsOut.setRows(5);
        jScrollPane2.setViewportView(sortResultsOut);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(33, 33, 33)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(enterInfo)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(title)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(16, 16, 16)
                                        .addComponent(tenNumsIn)
                                        .addGap(18, 18, 18)
                                        .addComponent(hundNumsIn)
                                        .addGap(10, 10, 10)
                                        .addComponent(thousNumsIn)
                                        .addGap(10, 10, 10)
                                        .addComponent(fiveThousNumsIn))))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(sortOrder)
                                .addGap(18, 18, 18)
                                .addComponent(ascending)
                                .addGap(18, 18, 18)
                                .addComponent(descending)))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap(29, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(origNums, javax.swing.GroupLayout.Alignment.TRAILING))
                        .addGap(23, 23, 23)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(sortedNums))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(sortResults)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(exit)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 365, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(sortNumbers)
                                .addComponent(errorHandling, javax.swing.GroupLayout.PREFERRED_SIZE, 365, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addGap(24, 24, 24))
            .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.TRAILING)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(title)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(enterInfo)
                    .addComponent(tenNumsIn)
                    .addComponent(hundNumsIn)
                    .addComponent(thousNumsIn)
                    .addComponent(fiveThousNumsIn)
                    .addComponent(sortNumbers))
                .addGap(7, 7, 7)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(sortOrder)
                    .addComponent(ascending)
                    .addComponent(descending))
                .addGap(32, 32, 32)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(origNums)
                    .addComponent(sortedNums)
                    .addComponent(sortResults))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 280, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(exit))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 310, Short.MAX_VALUE)
                        .addComponent(jScrollPane1)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 21, Short.MAX_VALUE)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(errorHandling, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /* A method called when the exit button is pressed. */
    private void exitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitActionPerformed

    /* A method called when the sort numbers button is pressed. */
    private void sortNumbersActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sortNumbersActionPerformed
        int[] iArrRandInts = null;   //Stores all random integer values
        String sEmptyString = "";   //Stores all random integer values as strings

        //if one radio button from each othe radio button groups is not selected
        if (amtNumsSort.getSelection() == null) {
            errorHandling.setText("Please select the amount of numbers in the list.");
        } else if (sortingOrder.getSelection() == null) {
            errorHandling.setText("Please select a sort order.");
        } else {
            errorHandling.setText(null);
            sortResultsOut.setText(null);

            if (tenNumsIn.isSelected() == true) {   //if want to sort 10 integers
                iArrRandInts = new int[10]; //array length is 10
            }
            if (hundNumsIn.isSelected() == true) {   //if want to sort 100 integers
                iArrRandInts = new int[100]; //array length is 100
            }
            if (thousNumsIn.isSelected() == true) {   //if want to sort 1000 integers
                iArrRandInts = new int[1000]; //array length is 1000
            }
            if (fiveThousNumsIn.isSelected() == true) {   //if want to sort 5000 integers
                iArrRandInts = new int[5000]; //array length is 5000
            }

            for (int x = 0; x < iArrRandInts.length; x++) { //Random integer generator
                iArrRandInts[x] = new Random().nextInt(10000 + 1 + 10000) - 10000;//Random integer generator with integers in ranges of -10000 to 10000 inclusive
                sEmptyString += iArrRandInts[x] + "\n";
            }
            originalNumsOut.setText(sEmptyString);

            //Copies of iArrRandInts
            int[] iArrRandInts2 = Arrays.copyOf(iArrRandInts, iArrRandInts.length);
            int[] iArrRandInts3 = Arrays.copyOf(iArrRandInts, iArrRandInts.length);
            int[] iArrRandInts4 = Arrays.copyOf(iArrRandInts, iArrRandInts.length);

            //Sorting functions
            selectionSort(iArrRandInts);
            bubbleSort(iArrRandInts2);
            insertionSort(iArrRandInts3);
            mergeSort(iArrRandInts4);
        }
    }//GEN-LAST:event_sortNumbersActionPerformed

    /* A method called when the sort numbers button is selected. */
    private void selectionSort(int[] iArrRandInts) {
        String sEmptyString = ""; //For storing sorted integers and output in text area
        int loops = 0;    //the number of times a loop is executed
        int numComparisons = 0;   //the number of time a comparison was made
        int numShifts = 0;    //the number of times a value was shifted
        long elasped = 0, start = 0, end = 0;  //the number of miliseconds to complete the sort;
        //For selection sort in ascending order
        if (ascending.isSelected() == true) {
            start = System.currentTimeMillis();
            for (int x = 0; x <= iArrRandInts.length - 1; x++) {
                int smallest = iArrRandInts[x];     //declares smallest integer variable
                for (int y = x + 1; y <= iArrRandInts.length - 1; y++) {
                    if (iArrRandInts[x] > iArrRandInts[y]) {
                        smallest = y;//index of new found smallest integer
                        //Swapping
                        int temp = iArrRandInts[x];
                        iArrRandInts[x] = iArrRandInts[smallest];
                        iArrRandInts[y] = temp;
                        numShifts++;
                    }
                    numComparisons++;
                    loops++;
                }
                loops++;
            }
            end = System.currentTimeMillis();
        }
        //For selection sort in descending order
        if (descending.isSelected() == true) {
            start = System.currentTimeMillis();
            for (int x = 0; x <= iArrRandInts.length - 1; x++) {
                int largest = iArrRandInts[x];     //declares largest integer variable
                for (int y = x + 1; y <= iArrRandInts.length - 1; y++) {
                    if (iArrRandInts[x] < iArrRandInts[y]) {
                        largest = y;//index of new found largest integer
                        //Swap index positions
                        int temp = iArrRandInts[x];
                        iArrRandInts[x] = iArrRandInts[largest];
                        iArrRandInts[y] = temp;
                        numShifts++;
                    }
                    numComparisons++;
                    loops++;
                }
                loops++;
            }
            end = System.currentTimeMillis();
        }
        elasped = end - start;
        //Sends info to Sort Results
        sortResultsOut.append("Selection Sort" + "\n"
                + "Number of times the loop was executed: " + loops + "\n"
                + "Number of times a comparison was made: " + numComparisons + "\n"
                + "Number of times a values was shifted: " + numShifts + "\n"
                + "Number of miliseconds to complete sort: " + elasped + "\n");
    }

    /* A method called when the sort numbers button is selected. */
    private void bubbleSort(int[] iArrRandInts) {
        String sEmptyString = ""; //For storing sorted integers and output in text area
        int iBottom = iArrRandInts.length - 1;
        int loops = 0;  //the number of times a loop is executed
        int numComparisons = 0;    //the number of time a comparison was made
        int numShift = 0;    //the number of times a value was shifted
        long elasped = 0, start = 0, end = 0;  //the number of miliseconds to complete the sort;
        Boolean swap = true;
        //For bubble sort in ascending order
        if (ascending.isSelected() == true) {
            start = System.currentTimeMillis();
            while (swap == true) {
                loops++;
                swap = false; //stays true if no swaps have been made at the end of the loop
                for (int x = 0; x <= iBottom - 1; x++) {
                    if (iArrRandInts[x] > iArrRandInts[x + 1]) {//if current element is greater than next element
                        //Swap index positions
                        int temp = iArrRandInts[x];
                        iArrRandInts[x] = iArrRandInts[x + 1];
                        iArrRandInts[x + 1] = temp;
                        numShifts++;
                        swap = true;
                    }
                    numComparisons++;
                    loops++;
                }
                iBottom--; //number of comparisons needed decreases for each while iteration
            }
            end = System.currentTimeMillis();
        }
        //For bubble sort in descending order
        if (descending.isSelected() == true) {
            start = System.currentTimeMillis();
            while (swap == true) {
                loops++;
                swap = false;
                for (int x = 0; x <= iBottom - 1; x++) {
                    if (iArrRandInts[x] < iArrRandInts[x + 1]) {//if current element is smaller than next element
                        //Swap index positions
                        int temp = iArrRandInts[x];
                        iArrRandInts[x] = iArrRandInts[x + 1];
                        iArrRandInts[x + 1] = temp;
                        numShifts++;
                        swap = true;
                    }
                    numComparisons++;
                    loops++;
                }
                iBottom--; //number of comparisons needed decreases for each while iteration
            }
            end = System.currentTimeMillis();
        }
        elasped = end - start;
        //Sends info to Sort Results
        sortResultsOut.append("Bubble Sort" + "\n"
                + "Number of times the loop was executed: " + loops + "\n"
                + "Number of times a comparison was made: " + numComparisons + "\n"
                + "Number of times a values was shifted: " + numShifts + "\n"
                + "Number of miliseconds to complete sort: " + elasped + "\n");
    }

    /* A method called when the sort numbers button is selected. */
    private void insertionSort(int[] iArrRandInts) {
        String sEmptyString = ""; //For storing sorted integers and output in text area
        int loops = 0;    //the number of times a loop is executed 
        int numComparisons = 0;   //the number of time a comparison was made
        int numShifts = 1;   //the number of times a value was shifted
        long elasped = 0, start = 0, end = 0;  //the number of miliseconds to complete the sort;
        //For insertion sort in ascending order
        if (ascending.isSelected() == true) {
            start = System.currentTimeMillis();
            for (int x = 1; x < iArrRandInts.length; x++) {
                int temp = iArrRandInts[x];
                int y = x - 1;
                while (y >= 0 && iArrRandInts[y] > temp) {
                    //Swap index positions
                    iArrRandInts[y + 1] = iArrRandInts[y];
                    y--;
                    numShifts++;
                    loops++;
                    numComparisons++;
                }
                iArrRandInts[y + 1] = temp;
                numShifts++;
                loops++;
            }
            end = System.currentTimeMillis();
        }
        //For insertion sort in descending order
        if (descending.isSelected() == true) {
            start = System.currentTimeMillis();
            for (int x = 1; x < iArrRandInts.length; x++) {
                int temp = iArrRandInts[x];
                int y = x - 1;
                while (y >= 0 && iArrRandInts[y] < temp) {
                    numShifts++;
                    //Swap index positions
                    iArrRandInts[y + 1] = iArrRandInts[y];
                    y--;
                    numShifts++;
                    loops++;
                    numComparisons++;
                }
                iArrRandInts[y + 1] = temp;
                numShifts++;
                loops++;
            }
            end = System.currentTimeMillis();
        }
        elasped = end - start;
        //Sends info to Sort Results
        sortResultsOut.append("Insertion Sort" + "\n"
                + "Number of times the loop was executed: " + loops + "\n"
                + "Number of times a comparison was made: " + numComparisons + "\n"
                + "Number of times a values was shifted: " + numShifts + "\n"
                + "Number of miliseconds to complete sort: " + elasped + "\n");
    }

    int loops = 0;    //the number of times a loop is executed
    int numComparisons = 0;   //the number of time a comparison was made
    int numShifts = 0;  //the number of times a value was shifted
    long start = 0;

    /* A method called when the sort numbers button is selected. */
    private void mergeSort(int[] iArrRandInts) {
        String sEmptyString = ""; //For storing sorted integers and output in text area
        long elasped = 0, end = 0;  //the number of miliseconds to complete the sort;        
        int[] iArrSorted = mergeSplitting(iArrRandInts);
        end = System.currentTimeMillis();
        //Adds all sorted integers to an empty string and outputs
        for (int x = 0; x < iArrSorted.length; x++) {
            sEmptyString += iArrSorted[x] + "\n";
        }
        sortNumsOut.setText(sEmptyString);

        elasped = end - start;
        //Sends info to Sort Results
        sortResultsOut.append("Merge Sort" + "\n"
                + "Number of times the loop was executed: " + loops + "\n"
                + "Number of times a comparison was made: " + numComparisons + "\n"
                + "Number of times a values was shifted: " + numShifts + "\n"
                + "Number of miliseconds to complete sort: " + elasped + "\n");
    }

    /* A method called in mergeSort. */
    private int[] mergeSplitting(int[] iArrRandInts) {
        start = System.currentTimeMillis();
        int[] arrLeft = new int[iArrRandInts.length / 2];
        int[] arrRight;
        if (iArrRandInts.length == 1) {     //base case
            return iArrRandInts;
        } else //Splits list apart
        {
            if (iArrRandInts.length % 2 == 1) { //if an odd number of integers needs to be sorted
                arrRight = new int[iArrRandInts.length / 2 + 1];
            } else { //if an even number of integers needs to be sorted
                arrRight = new int[iArrRandInts.length / 2];
            }
        }
        //send integers to left half of array
        for (int x = 0; x < arrLeft.length; x++) {
            arrLeft[x] = iArrRandInts[x];
            loops++;
        }
        //send integers to right half of array
        for (int x = 0; x < arrRight.length; x++) {
            arrRight[x] = iArrRandInts[x + iArrRandInts.length / 2];
            loops++;
        }
        int[] sortedLeftArr = mergeSplitting(arrLeft);
        int[] sortedRightArr = mergeSplitting(arrRight);
        int[] mergedArray = merging(sortedLeftArr, sortedRightArr);

        return mergedArray;
    }

    /* A method called in mergeSplitting. */
    private int[] merging(int[] arrSortedLeft, int[] arrSortedRight) {
        int iLeftIndex = 0, iRightIndex = 0; //keeps track of if left or right array element has been taken from
        ArrayList<Integer> arrMerge = new ArrayList<>();
        //For merge sort in ascending order
        if (ascending.isSelected() == true) {
            while (true) {
                loops++;
                if (iLeftIndex < arrSortedLeft.length && iRightIndex < arrSortedRight.length) { // check if the end of any array is reached
                    numComparisons++;
                    if (arrSortedLeft[iLeftIndex] < arrSortedRight[iRightIndex]) {      // the one in the left list is smaller
                        arrMerge.add(arrSortedLeft[iLeftIndex]);        // add the left list element into the arraylist
                        numShifts++;
                        iLeftIndex++;
                    } else {
                        arrMerge.add(arrSortedRight[iRightIndex]);      // the right one is smaller, add it to the arraylist
                        numShifts++;
                        iRightIndex++;
                    }
                } else if (iLeftIndex == arrSortedLeft.length) {    // left array end reached. copy the rest of right array into the arraylist
                    for (int i = iRightIndex; i < arrSortedRight.length; i++) {
                        numShifts++;
                        arrMerge.add(arrSortedRight[i]);
                    }
                    break;
                } else if (iRightIndex == arrSortedRight.length) {  // right array end reached. copy the rest of left array into the arraylist
                    for (int i = iLeftIndex; i < arrSortedLeft.length; i++) {
                        numShifts++;
                        arrMerge.add(arrSortedLeft[i]);
                    }
                    break;
                }
            }
        }
        //For merge sort in descending order
        if (descending.isSelected() == true) {
            while (true) {
                loops++;
                if (iLeftIndex < arrSortedLeft.length && iRightIndex < arrSortedRight.length) { // check if the end of any array is reached
                    numComparisons++;
                    if (arrSortedLeft[iLeftIndex] > arrSortedRight[iRightIndex]) {      // the one in the left list is bigger
                        arrMerge.add(arrSortedLeft[iLeftIndex]);        // add the left list element into the arraylist
                        numShifts++;
                        iLeftIndex++;
                    } else {
                        arrMerge.add(arrSortedRight[iRightIndex]);      // the right one is bigger, add it to the arraylist
                        numShifts++;
                        iRightIndex++;
                    }
                } else if (iLeftIndex == arrSortedLeft.length) {    // left array end reached. copy the rest of right array into the arraylist
                    for (int i = iRightIndex; i < arrSortedRight.length; i++) {
                        numShifts++;
                        arrMerge.add(arrSortedRight[i]);
                    }
                    break;
                } else if (iRightIndex == arrSortedRight.length) {  // right array end reached. copy the rest of left array into the arraylist
                    for (int i = iLeftIndex; i < arrSortedLeft.length; i++) {
                        numShifts++;
                        arrMerge.add(arrSortedLeft[i]);
                    }
                    break;
                }
            }
        }

        int[] mergedArray = new int[arrMerge.size()];
        for (int i = 0; i < arrMerge.size(); i++) {     // turn the array list into an array
            mergedArray[i] = arrMerge.get(i);
        }
        return mergedArray;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(sTrangWk13SortingEfficiencies.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(sTrangWk13SortingEfficiencies.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(sTrangWk13SortingEfficiencies.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(sTrangWk13SortingEfficiencies.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new sTrangWk13SortingEfficiencies().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup amtNumsSort;
    private javax.swing.JRadioButton ascending;
    private javax.swing.JRadioButton descending;
    private javax.swing.JLabel enterInfo;
    private javax.swing.JTextField errorHandling;
    private javax.swing.JButton exit;
    private javax.swing.JRadioButton fiveThousNumsIn;
    private javax.swing.JRadioButton hundNumsIn;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JLabel origNums;
    private javax.swing.JTextArea originalNumsOut;
    private javax.swing.JButton sortNumbers;
    private javax.swing.JTextArea sortNumsOut;
    private javax.swing.JLabel sortOrder;
    private javax.swing.JLabel sortResults;
    private javax.swing.JTextArea sortResultsOut;
    private javax.swing.JLabel sortedNums;
    private javax.swing.ButtonGroup sortingOrder;
    private javax.swing.JRadioButton tenNumsIn;
    private javax.swing.JRadioButton thousNumsIn;
    private javax.swing.JLabel title;
    // End of variables declaration//GEN-END:variables
}
